# Week-01总结
## 知识点总结
### 数组&变长数组
1. 内存中一段连续的地址空间
2. 数组遍历时，通过数组首地址+元素类型占用空间*索引，快速定位索引位置
3. 由于地址空间连续，遍历数组时间复杂度O(1)
4. 数组在插入和删除元素（非尾部），需要移动插入位置后的数组元素
5. 插入/删除数组元素时，时间复杂度O(n)
6. 数组尾部插入删除元素的时间复杂度O(1)
7. 数组头部插入删除元素的时间复杂度O(n)
8. Java中常用的变长数组为ArrayList，其底层基于数组实现
    - 当空间不足时，重新申请2倍大小的数组，同时进行数组元素copy
    - 空间利于率不足25%时，释放一半空间
    - 扩容/缩容的时间复杂度O(1)

### 链表
#### 单链表
1. 单链表节点的主要结构，next指向下一个节点，从而形成单链表
```
class Node{
    int value;
    Node next;
}
```
2. 如果单链表的尾节点next再指向头节点，形成循环单链表
3. 通常会建立保护节点，指向空链表，防止空指针
4. 删除节点
    - 模板
    ```
    node.next = targetNode.next;
    ```
    - 时间复杂度O(1)
5. 插入节点
    - 模板
    ```
    newNode.next = node.next;
    node.next = newNode;
    ```
    - 时间复杂度O(1)
6. 单链表的查询，需要从头节点遍历，一直找到目标节点
    - 最好情况，目标节点为头节点，时间复杂度O(1)
    - 最坏情况，目标节点为尾节点，时间复杂度O(n)
    - 任意查询节点的平均复杂度为O(n)

#### 双链表
1. 双链表节点的主要结构，next指向后继节点，pre指向前驱节点
```
class Node{
    int value;
    Node pre;
    Node next;
}
```
2. 通常会建立保护节点，代表空双链表，防止空指针
```
Node head = new Node();
Node tail = new Node();
head.next = tail;
tail.pre = head;
```

### 栈
1. 先进后出
2. 访问，push和pop的时间复杂度都是O(1)
3. 处理最近相关性，一般会采用栈

### 队列
1. 先进先出
2. 访问，push和pop的时间复杂度都是O(1)

### 双端队列
1. 头尾都可以插入和删除
2. 头尾都可以插入、删除和访问的时间复杂度是O(1)

### 优先队列
1. 可以按照自定义的优先级取出队列元素
2. 可以使用二叉堆或二叉平衡树实现优先队列
3. 访问最值的时间复杂度O(1)
4. 插入的时间复杂度一般是O(logN)，一些高级数据结构可做到O(1)
5. 取最值的时间复杂度是O(logN)

## 解题思路总结
### 关于表达式求值问题
#### 前缀表达式
1. 形如"op AB"，又称波兰表达式

#### 后缀表达式
1. 形如"AB op"，又称逆波兰表达式
2. 求值相对比较简单，一般中缀表达式的求值，可以转换为后缀表达式来求值

#### 中缀表达式
1. 形如"A op B"

### 前缀和
1. 公式: S[i] = S[i-1] + A[i]
2. 子段和公式：sum(l,r) = S[r] - S[l-1]
3. 当数组非负时，前缀和数组S单调递增
4. 二维前缀和公式：S[i][j] = S[i-1][j] + S[i][j-1] -S[i-1][j-1] + A[i][j]
5. 子矩阵和公式：sum(p,q,i,j) = S[i][j] - S[i][q-1] -S[p-1][j] + S[p-1][q-1]，(p,q)为左上角，（i，j）为右下角
6. 满足区间减法（[l,r]的信息可以有[1,r] 和 [1, l-1]的信息导出），可以用前缀和

### 差分
1. 定义
    - 数组A
    - 差分数组B
    - 满足：B[1] = A[1]，B[i] = A[i] - A[i-1]，2 <= i <= n
2. 差分数组B的前缀和数组就是原数组A
3. 原数组A的l~r个数+d, 则B[l] = B[l] + d， B[r+1] = B[r+1] - d

### 双指针扫描
1. 解决一类介于"子段"的统计问题
    - 子段：数组中连续的一段，下标可以用一个闭区间来表示
    - 朴素做法：两重循环枚举，可以通过去除冗余部分来优化
    - 优化策略
        - 固定右端点，看左端点的取值范围
        - 移动一个端点，看另一个端点的变化情况
2. 维护的信息是关于一个点的，可以使用双指针扫描

### 单调栈
1. 代码套路
```
for循环每个元素{
    while(栈顶于新元素不满足单调性){
        弹栈，更新答案 
    }
    
    入栈
}
```

### 单调队列
1. 思维套路
   - 单调队列维护的是一个候选集合 
   - 满足时间单调性，当索引递增时，前面的比较旧，后边的比较新
   - 候选项的某个属性也具有单调性，如元素的值
   - 确定递增递减的方法
      - 考虑任意两个候选项，i1<i2(时间递增)，写出i1比i2优的条件
      - 如果array[i1]>array[i2]，递减
      - 如果array[i1]<array[i2]，递增
   - 排除冗余的关键
      - 若i1比i2差，i1的生命周期比i2还短，那么i1就是冗余
2. 代码套路
```
//注意2和3的顺序取决于i是不是侯选项
for循环每个元素{
    //1判断合法性，从时间维度，判断是否过期，如小表是否超出范围
    while(队头过期){
        1.1 队头出队
    }
    
    //2
    取队头为最佳选项，计算答案

    //3判断队尾的值与新元素是否满足递增或是递减
    while(队尾与新元素不满足单调性){
        3.1 队尾出队
    }
    3.2 新元素入队
}
```
2. 维护的信息是关于一整个候选集(多个点)，使用单调队列

## 心得
1. 没有系统学习过算法，在实际应用开发中很少自己实现算法,只是了解一些简单的数据结构和算法，不成体系。
2. 通过学习课上列题实战部分，对面临一道算法问题时，如何去思考，梳理解题思路有了一点点掌握，需要通过实践（三刷五步）不断去学习和提高。