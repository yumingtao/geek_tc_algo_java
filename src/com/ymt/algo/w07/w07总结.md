# Week-07总结

## 知识点总结

### 字典树 - Trie树
1. 介绍
    - 一种由"节点"和"带有字符的边"构成的树形结构
    - 典型应用：统计和排序大量的字符串（不仅限于），经常被搜索引擎系统用于文本词频统计
    - 优点：最大限度的减少无谓的字符串比较，查询效率比哈希表高
    
2. 基本性质
    - 节点本身不保存完整单词
    - 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的单词
    - 每个节点出发的所有边代表的字符都不相同
    - 节点用于存储单词的额外信息，例如频次等
    
3. Trie树的内部实现
    - 字符集数组法
        - 每个节点保存一个固定为字符集大小的数组，以字符为下标，保存指向的节点
        - 空间复杂度O(节点数*字符集大小)
        - 查询的时间复杂度O(单词长度)
        - 适用于较小字符集，或单词短，分布稠密的字典
    - 字符集映射法
        - 每个节点保存一个映射，根据使用场景，如果做为词频统计，则使用HashMap，如果需要保证顺序，则使用OrderMap
        - 空间复杂度O(文本字符数)，以每个字符做为key，Map的size就是文本字符数
        - 查询的时间复杂度O(单词长度)，但常数比使用字符集数组稍大一些
        - 和字符集数组法相比，适用性更广
        
4. 核心思想
    - 空间换时间
    - 无论是保存树的结构、字符集数组还是字符集映射，都需要额外的空间
    - 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的
    - 前缀相同的字符串在同一子树中的分组思想

#### 并查集 - Disjoint Set
1. 基本用途
   - 处理不相交集合的合并和查询
   - 处理分组
   - 维护无序二元关系
   
2. 基本操作
   - MakeSet(s)
      - 建立一个新的并查集，其中包含S个集合，每个集合里只有一个元素
   - UnionSet(x, y)
      - 如果元素x和元素y不相交，合并元素x和y所在的集合，如果相交则无需合并
   - Find(x)
      - 找到元素x所在的集合代表
      - 也可用于将它们的各自代表比较一下，来判断两个元素是否位于同一个集合
   
3. 内部实
   - 每个集合是一个树形结构，其中每个节点只保存一个值，即它的父亲节点
   - 最简单的实现是一个int数组fa，fa[x]表示x节点的父节点，根节点等于它自己
   
4. 路径压缩
   - 在Find(x)的同时，同时把x和x的所有祖先直接连到根节点，下一次可以直接走到根
   - 采用路径压缩, Find(x)的均摊时间复杂度O(logn)
   
5. Java代码模板
```
class DisjointSet{
    int[] fa;
    public DisjointSet(){
        fa = new int[n];
        for (int i = 0; i < n; i++){
            fa[i] = i;
        }
    }
    
    public int find(int x){
        if(x == fa[x]){
            return x;
        }
        
        return fa[x] = find(fa[x]);
    }
    
    public void unionSet(int x, int y){
        x = find(x);
        y = find(y);
        
        if(x != y){
            fa[x] = y;
        }
    }
}
```
## 算法思路总结
