# Week-10总结

## 知识点总结

### 树状数组与线段树

#### 树状数组 - Binary Indexed Tree or Fenwick Tree

1. 基本知识
    - 一种维护数组区间和、前缀和的数据结构
    - 与跳表类比
        - 跳表：通过添加索引，高效维护链表，解决链表查询较慢的问题（普通链表查询时间复杂度O()）
        - 树状数组：通过添加索引，高效维护数组
2. 如何建立索引
    - 一个节点的原始索引的数据数量与该节点编号在二进制下最低位的1有关
    - 如果二进制下以1结尾，只索引节点本身一个数据
    - 如果二进制下以10结尾，索引两个数据，索引自身和其前边的一个数据
    - 如果二进制下以100结尾，索引四个数据，索引自身和其前边的三个数据

3. lowbit
    - 二进制转十进制是通过2的幂次和计算的，所以任意正整数可以分解为若干个不重复的2的次幂之和
    - lowbit定位为，x在二进制下，最低为的1和1后面的0组成的数值或x在二进制分解下的最小次幂
        - 如lowbit(12)=lowbit(1100)=(100)=2^2=4
4. 性质
    - 节点c[x]
        - 保存以它为根的子树中所有叶子节点的和
    - 除树的跟节点外，每个内部节点的父亲是c[x + lowbit(x)]
    - 树深度O(logn)
    - 如果n不是2的整次幂，树状数组是一个不包含根节点的具有同样性质的森林结构

5. 查询
    - 任意区间[1,x]，通过二进制分解，可以拆分成O(logn)个区间
        - 如[1, 13]
            - 13 = 2^3 + 2^2 + 2^0 = 8 + 4 + 1
            - [1, 13]可以拆分成[1, 8]，[9, 12]，[13, 13]
        - 规律
            - 13前面的lowbit(13)=1个数，即[13, 13], 13 - 1 = 12，下一个x为12
            - 12前面lowbit(12)=4个数，以12做为区间上限，长度为4，即[9, 12], 12 - 4 = 8，下一个x为8
            - 8前面lowbit(8)=8个数，以8为区间上限，长度为8，即[1, 8]，8 - 8 = 0，结束
    - 求前缀和代码模板
        - 根据树状数组的性质，节点c[x]保存以它为根的子树中所有叶子节点的和
        - 那么前缀和，也是x自己和前面lowbit(x)个数据的和
        - 如13=(1101)，数组前13的前缀和 = 13 + c[12] + c[8]
        - 代码模板
      ```
         int query(int x){
            int ans = 0;
            //x -= x&-x表示x-lowbit(x)
            
            for(;x>0;x -= x&-x){
               ans += c[x];
            }
         
            或
            while(x>0){
               ans += c[x];
               x -= x&-x;
            }
         
            return ans;
         }
      ```
    - 求区间和[l,r]
        - 就是前r个数的前缀和-前l-1个数的前缀和，即query(r) - query(l-1)
    - 求c[x], c[x]=query(x-1)+a[x]
    - 查询的时间复杂度不超过O(logn), 即不超过x二进制得到位数

6. 原数组单点更新
    - 假设x上增加y
    - 那么c[x]及其祖先都要加y
    - 利用c[x]的父亲节点是c[x + lowbit(x)]的性质
    - 代码模版
   ```
      void add(int x, int y){
         //x&-x表示lowbit(x)
         for(;x<=n;x+=x&-x){
            c[x]=c[x]+y;
         }
      
         或
         while(x<=n){
            c[x]+=y;
            x += x&-x;
         }
      }
   ```
    - 时间复杂度O(logn)
    - 如果要更新为一个值，可以先计算差值，再执行add(差值)

7. 优点与局限性
    - 优点
        - 实现简单
        - 效率高
        - 节省空间
    - 局限性
        - 维护的信息需要满足区间减法性质，不然无法通过前缀和相减得到区间和
        - 不能维护区间最值
        - 不能很好的支持修改操作
            - 单点修改需要先求出差值，转化为增加操作
            - 基本上难以支持区间修改(修改连续的一段数据)

#### 线段树 - Segment Tree

1. 基本知识
    - 一种基于分治思想的二叉树结构，用于区间上进行信息统计
    - 线段树上每个节点都代表一个比区间
    - 线段树具有唯一的根节点，代表的区间是整个统计范围，如[1, N]
    - 线段树的每个叶节点都代表一个长度为1的元区间[x,x]
    - 对于每个内部节点[l,r],它的左节点是[l,mid],右节点是[mid+1, r],mid=(l+r)/2

2. 性质
    - 出去树的最后一层，整棵线段树一定是一棵完全二叉树
    - 树的深度是O(logn)

3. 保存与节点编号
    - 可采用与二叉堆类似的编号方法
        - 如果根节点编号是1
        - 节点p的左子节点编号为2*p，右子节点编号2*p+1
    - 可以使用数组保存
        - 注意：数组长度不要小于4N

4. 区间修改的解决方案 - 懒惰标记（延迟标记）
   - 思想：mark一下这个bug要改，如果以碰到了，先改一下再run，碰不到就暂时不管
   - 遇到完全覆盖的区间，先打一个修改标记，只要不到叶子节点中查询，就不往下继续修改，因为父节点的data中已经更新，可以直接使用data中的统计信息
   - 在以后的递归查询中或修改中，如果遇到了标记再修改，然后把mark再向下传递一层，以后遇到时再改
   - 时间复杂度优化到O(logn)

### 离散化
   - 把无穷集合中的若干个元素映射为有限集合以便于维护
   - 最常见场景
      - 坐标范围-1e9～1e9，任意实数，其中只有N个坐标有用
   - 解决思路
      - 出现过的坐标按大小顺序映射为1,2,3,...,N
      - 可用算法：排序去重+二分
      - 或直接用SDK内置数据结构：Java中的TreeSet、TreeMap

### 各种树形数据结构的对比
|数据结构|用途|n次操作时间复杂度
|---|---|---
|并查集|关系维护，图的连通性、利用路径压缩等|O(nα(n))
|Trie树|维护字典，多个字符串的存储和查询|O(字符串长度)
|二叉堆|最大最小值的维护与查询|O(nlogn)
|树状数组|区间信息的维护与查询（需要满足区间减法性质）|O(nlogn)
|线段树|区间信息的维护与查询|O(nlogn)
|平衡二叉树|实现有序集合/映射<br>更加灵活的区间信息的维护与查询|O(nlogn)

### 位运算

1. 基础
    - 计算机底层采用二进制对数值进行表示、存储、运算
    - 程序中适当使用二进制，可以提高运行效率
    - 十进制转二进制采用短除法
        - 将商不断的模2，当商==0时，将余数倒序
    - 二进制转十进制采用幂次和
        - 右边是最低位，记为第0位，向左依次+1，做为幂次
        - 从最低位开始，依次用每一位的数0/1与2的i次幂相乘后再相加求和
2. 为运算符

   |运算符|含义|注释|示例|特点及应用
                                                                                                                           |---|---|---|---|---
   |&|按位与|都是1得1，否则得0|1011 & 0011 -> 0011|任何数与1取&都得其本身，0与任何数&都是0
   |&#124;|按位或|都是0得0，否则得1 |1011 &#124; 0011 -> 1011 |0与任何数取或都得其本身
   |~|按位取反|1得0，0得1|0011 -> 1100 |
   |^|按位异或,xor|相同得0，不同得1,可以理解为不进位加法|1011 ^ 0011 -> 1000|x^0=x 任何数与0异或都得其本身<br>  x^x=0 任何数与其本身异或都得0<br> 结合律：a^b^c=a^(b^c)=(a^b^c) <br> 成对变换：x^1 <br> 交换两个数：a=a^b;b=a^b;a=a^b;
   |<<|算术左移|舍去高位，低位补0|0011 -> 0110|在java中为有符号的左移位操作，相当于乘2。逻辑左移为<<<,表示无符号的移左
   |\>>|算术右移|舍去低位，正数时高位补0，负数时高位补1，为符号位|0011 -> 0001|在java中为有符号的右移位操作，相当于除以2。逻辑右移为>>>，表示无符号的右移，高位补0

3. 指定位置的位运算
    - 获取x在二进制下的第n位
        - 利用1(二进制表示为...0001)与任何数按位&都是其本身，0与任何数&都是0的特点
        - 先将需要判断的位左移到与1的最低位，第0位的1对齐，然后&
        - 判断是1 ：((x>>n) & 1) == 1
        - 判断是0 ：((x>>n) & 1) == 0
    - 设置x在二进制下的第n位
        - 设置为1：x｜(1<<n)
            - 先把1(二进制...0001)中的1移动到n的位置，利用任何数与1取或都是1的特点
        - 设置为0：x & (~(1<<n))
            - 先把1(二进制...0001)中的1移动到n的位置，然后取反，使第n个位置变为0，其余都是1
            - 利用1与任何数&都是数本身，0与任何数&都是0的特点
    - 将x在二进制下的第n位取反
        - x ^ (1<<n)
        - 先把1(二进制...0001)中的1移动到n的位置
        - 利用0与任何数^都是其本身，1^1=0的特性
    - 将x最右边的n个位置清零
        - x & (~0<<n)
        - 先把0(二进制...0000)取反，使之都变成1
        - 然后左移n位，让右边的n个位置都补0
        - 利用0与任何数&都是0的特性
    - 将x最高位至第n(含)个位置清零
        - x & ((1<<n)-1)
        - 先把1(二进制...0001)左移n位，变成...0001000...
        - 再-1，-1操作会借位，变成 ..0000111..，刚好把最高位到n的位置都变为0，后边全是1
        - 然后再&，利用0与任何数&都是0的特性

4. 位运算实战要点
    - 判读奇偶，利用1与任何数&都是其本身的特点
        - 判断偶数： x % 2 == 0，可换为 (x&1) == 0，
        - 判断奇数： x % 2 == 1，可换为 (x&1) == 1
        - 注意：偶数的最低位是0，奇数的最低位是1
    - 除以2的幂次
        - x/2 -> x>>1
    - 乘以2的幂次
        - x*2 -> x<<1
    - lowbit
        - 得到最低位的1：x&-x 或 x&(~x+1)
        - 清零最低位的1：x=x&(x-1) 或 x=x-(x&-x) 即 x -= x & -x，可以理解位x减去最低位的1

5. 注意点
    - 位运算操作的优先级比较低，在实际应用过程中，注意使用括号来提高优先级