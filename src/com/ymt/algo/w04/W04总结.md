# Week-04总结
## 知识点总结
### 堆
1. 什么是堆 - Heap
    - 一种高效维护集合中最大或最小元素的数据结构
        - 大根堆：根节点最大的堆
        - 小根堆：根节点最小的堆
    - 是一棵满足堆性质的二叉树
        - 大根堆:父>=子
        - 小根堆:父<=子
2. 二叉堆-Binary Heap
    - 本质上是一个满足堆性质的完全二叉树
3. 二叉堆的实现
    - 使用一元数组存储
    - 节点编号特性满足，假设节点索引为p
        - 下标从1开始
            - 节点左孩子索引p*2
            - 节点右孩子索引p*2+1
            - 节点父亲节点索引p/2
        - 下标从0开始
            - 节点左孩子索引p*2+1
            - 节点右孩子索引p*2+2
            - 节点父亲节点索引(p-1)/2
4. 二叉堆的常见操作
    - 建堆: 时间复杂度O(N)
    - 查询最大值/最小值: 时间复杂度O(1)，直接读取根节点
    - 插入：时间复杂度O(logN)
    - 取出最值:时间复杂度O(logN)，取出并删除根节点，然后对二叉堆重新选出根节点
5. 大根二叉堆的插入过程
    - 新元素插入到数组heap尾部
    - 向上进行调整，假设插入到了索引p的位置，数组下标从1开始，调整步骤如下
        - 如果到达堆顶即数组起始位置，停止
        - p节点的父亲节点索引是p/2，如果满足heap[p]<=heap[p/2]，停止
        - 如果heap[p]>heap[p/2]，交换节点p和父亲节点p/2，然后设置p=p/2，继续向上调整
6. 大根堆取出堆顶，即删除堆顶，步骤如下
    - 将堆顶heap[1]与堆尾heap[n]交换，删除堆尾，即交互数组第一个元素和最后一个元素，然后删除数组最后一个元素
    - 因为堆尾元素肯定不是heap数组中最大的节点，所以需要依次向下调整，调整步骤
        - 每次与左右子节点中较大的比较，如果大于等于较大的，停止，如果小于较大的，与之交换，然后继续向下调整
        - 注意判断子节点是否存在
7. 小根二叉堆的插入过程
    - 新元素插入到heap数组尾部
    - 向上进行调整，假设插入到了索引p的位置，数组下标从1开始，调整步骤如下
        - 如果到达堆顶即数组起始位置，停止
        - p节点的父亲节点索引是p/2，如果满足heap[p]>=heap[p/2]，停止
        - 如果heap[p]<heap[p/2]，交换节点p和父亲节点p/2，然后设置p=p/2，继续向上调整
8. 小根堆取出堆顶，即删除堆顶，步骤如下
    - 将堆顶heap[1]与堆尾heap[n]交换，删除堆尾，即交互数组第一个元素和最后一个元素，然后删除数组最后一个元素
    - 因为堆尾元素肯定不是heap数组中最小的节点，所以需要依次向下调整，调整步骤
        - 每次与左右子节点中较小的比较，如果小于等于较小的，停止，如果大于较小的，与之交换，然后继续向下调整
        - 注意判断子节点是否存在，防止出现空指针异常        
9. 理论上，二叉堆可以支持删除任意元素，步骤
    - 定位该元素在堆数组中的索引p
    - 与堆尾交换，删除堆尾
    - 从索引p开始，向上向下各进行依次调整
    
### 优先队列 - Priority Queue
1. 二叉堆是优先队列一种简单常见的实现，但不是最优实现
2. 优先队列没有提供删除任意元素的方法
3. 在Java中如果需要支持删除任意元素，可以使用基于平衡二叉树的有序集合，如TreeMap
    
### 关于取整
1. 在计算完全二叉树父、子节点索引和二分查找范围的时候会用到
    - (n+1)/2 : 向上取整
    - (n-1)/2 : 向下取整

### 二叉搜索树 Binary Search Tree (BST)
1. 定义
   - 任意节点的关键值>=它左子树中所有节点的关键值
   - 任意节点的关键值<=它右子树中所有节点的关键值
2. 二叉搜索树的中序遍历必然是一个有序序列
3. BST的建立
   - 建立两个保护节点，避免越界，减少边界情况的特使判断
   - 建立两个节点的空BST
      - 一个节点的关键值是正无穷大
      - 一个节点的关键值是负无穷大
4. BST的检索，检索关键值val是否存在
   - 从根节点开始递归查找
   - 当前节点的关键值==val，找到返回
   - 当前节点的关键值>val，说明要检索的值在当前节点的左子树，递归检索左子树，也可能不存在
   - 当前节点的关键值<val，说明要检索的值在当前节点的右子树，递归检索右子树，也可能不存在
   - 时间复杂度
      - 随即数据，最快O(logn)
      - 非随机数据，最坏O(n)
5. BST的插入，类似于检索的过程
   - 若检索到，则放弃插入或是对应节点计数+1
   - 若检索发现不存在（子树为空），直接新建关键值为val的节点
   - 时间复杂度
      - 随即数据，最快O(logn)
      - 非随机数据，最坏O(n)
6. BST求前驱，BST中小于val的最大节点
   - 基于检索，先检索val
   - 检索到val
      - 存在左子树，则左子树中一直遍历右子树到叶子节点
      - 不存在左子树，后继在检索过程经过的所有祖先节点中
   - 没有检索到val，后继在检索过程经过的所有祖先节点中
   - 时间复杂度
      - 随即数据，最快O(logn)
      - 非随机数据，最坏O(n)
7. BST求后继，BST中大于val的最小节点
   - 基于检索，先检索val
   - 检索到val
      - 存在右子树，则右子树中一直遍历左子树到叶子节点 
      - 不存在右子树，后继在检索过程经过的所有祖先节点中
   - 没有检索到val，后继在检索过程经过的所有祖先节点中
   - 时间复杂度
      - 随即数据，最快O(logn)
      - 非随机数据，最坏O(n)
8. BST的删除
   - 基于检索val+求后继
   - 首先检索val
   - 如果val所在节点只有一棵子树，直接删除val节点，把子树和父节点相连
   - 如果有两棵子树
      - 先找到后继，并删除后继
      - 用后继节点代替val节点的位置
      - 注意，后继是右子树一直遍历左子树到叶子几点，所以后继节点最多只有一棵右子树
      - 为什么要找后继，因为后继val节点右子树中最小的，使用后继替代val才能保证右子树的值都比后继大
  - 时间复杂度
     - 随即数据，最快O(logn)
     - 非随机数据，最坏O(n)
### 二分查找
1. 可以使用二分查找的前提条件
    - 目标单调递增或单调递减
    - 存在上下届
    - 可以通过索引来访问
    - 时间复杂度O(logn)
2. 普通二分查找模板
    - 注意普通二分查找模板在处理左右边界时，使用了mid +/- 1
```
int left = 0;
int right = n-1;
while(left <= right){
    int mid = (left + right)/2;
    if(array[mind] == target){
        //break or return mid
        return mid;
        //break;
    }
    
    if(array[mid] < target){
        //说明目标在有半段
        left = mid + 1;
    }else{
        //目标在左半段
        right = mid - 1;
    }
}
```
3. lower_bound&upper_bound与二分查找
    - lower_bound
        - 在一个单调递增数组中，查找第一个>=target的数/下标
        - 不存在则返回数组长度
    - upper_bound
        - 在一个单调递增数组中，查找第一个>target的数/下标
        - 不存在则返回数组长度
    - target不一定存在与数组中，按照普通二分查找的模板，正确答案可能会被mid +/- 1排除在边界之外
4. 改进的二分查找模板
    - 主要解决lower_bound和upper_bound查找target存在的问题
    - 同样可以替代普通的二分查找模板
    - 模板1.1，终止于left==right
    ```
    //lower_bound，查找第一个>=target的数
    int left = 0;
    int right = n; //注意这里是n，而不是n-1
    
    while(left < right){//注意这里是<，而不是<=
        int mid = (left + right) / 2;
        if(array[mid] >= target){//注意是>=，和lower_bound定义的条件一致
            //array[mid]的值已经>=target
            //说明结果可能在左半段，如果左半段没有结果，但至少array[mid]是满足要求的
            right = mid;//注意次数不是mid-1
        }else{
            //说明结果可能在右半段
            left = mid + 1;//array[mid]肯定不是答案，所以不用包含
        }
    }
    return right;
    ```
    - 模板1.2，终止于left==right
    ```
    //查找最后一个<=target的数（满足条件的数里取下标最大的），不存在返回-1
    int left = -1;//注意此处返回的是-1而不是0
    int right = n -1;
    while(left < right){//注意是<，而不是<=
        int mid = (left + right + 1) / 2;//注意此处要+1
        if(array[mid] <= target){//注意要和条件一致
            //说明左半段都是<=target，右半段可能还有
            left = mid;//注意这里是mid，在计算mid的时候要+1
        }else{
            //继续查询左半段
            right = mid - 1;//注意array[mid]肯定不是答案，此处不包含
        }
    }
    return right;
    ```
    - 双侧都不包含，使用ans维护答案，终止于left>right
    ```
    //查找最后一个<=target的数（满足条件的数里取下标最大的），不存在返回-1
    int left = 0;
    int right = n -1;
    int ans = -1;
    while(left <= right){
        int mid = (left + right) / 2;
        if(array[mid] <= target){//注意要和条件一致
            //维护最大下标
            ans = max(ans, mid);
            //说明左半段都是<=target，右半段可能还有
            left = mid + 1;
        }else{
            //继续查询左半段
            right = mid - 1;//注意array[mid]肯定不是答案，此处不包含
        }
    }
    return right;
    ```
    - 双侧都包含，终止于left+1=right，最后再检查答案
    ```
    //查找最后一个<=target的数（满足条件的数里取下标最大的），不存在返回-1
    //答案可能是left或right，也可能不存在
    int left = 0;
    int right = n -1;
    while(left + 1 < right){//注意此处是<，不是<=
        int mid = (left + right) / 2;
        if(array[mid] <= target){//注意要和条件一致
            //说明左半段都是<=target，右半段可能还有
            left = mid;
        }else{
            //继续查询左半段
            right = mid;//
        }
    }
    
    //此处需要处理left和right， 返回合适的答案
    return ?;
    ```

## 算法思路总结
### 二分查找
1. 不要局限于递增的数组或序列，当一些条件满足单调性时，同样可以使用二分的思想处理
2. 二分查找的关键在于找到分割两段的点