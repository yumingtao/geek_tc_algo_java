# Week-02总结
## 知识点总结
### 哈希表
1. 组成
    - 数据结构：数组或链表
    - Hash函数，通过key计算数据结构的索引
2. 原理：Hash函数计算出索引，在数据结构的索引位置存储value
3. 哈希碰撞
    - 两个不同的key计算出相同的索引
    - 通过开散列解决
        - 数据结构的索引位置存储链表头指针
        - 链表存储具有相同hash值的数据
4. 时间复杂度
    - 数据分布均衡时，插入、查询、删除都是O(1)
    - 最坏，hash值相同
        - 数据都存放在一个链表中，数据插入到尾部
        - 插入、查询、删除都需要遍历链表，时间复杂度O(n)

### set和map
1. set存储不重复元素
    - 元素有序，平衡二叉搜索树实现，时间复杂度O(logN)
    - 元素无序，哈希表实现，时间复杂度，O(logN)

2. map存储key-value
    - key有序，平衡二叉搜索树实现，时间复杂度O(logN)
    - 无序，哈希表实现，时间复杂度，O(logN)

### 递归
1. 递归模版
    - 终止条件
    - 逻辑处理
    - 进入到下一层
    - 恢复/清理资源
2. 注意事项
    - 递归时，先处理主体逻辑，再去处理终止条件
    - 计算好递归的终止条件
    - 达到终止条件，要返回递归底层结果
    - 在使用全局变量时，注意每层递归返回时，要进行恢复和清理，在代码中记得添加和删除要成对出现
3. 递归树时
    - 终止条件模板
    ```
    if(root == null){
        return 0;
    }
   ```
    - 注意，在递归的时候，深度要加1，因为模板返回的是0

### 分治
1. 分而治之，可以类比Map-Reduce
2. 把原问题划分成若干个同类子问题，分别解决再把结果合并
3. 关键点在于划分同类子问题和合并结果
4. 分治算法一般用递归实现
5. 划分标准：不重不漏

## 思路总结
### LRU - Least Recently Used
1. 最近最少使用
2. 淘汰最旧的数据
3. 可以使用Map+双向链表实现
    - 双向链表用于按时间顺序保存数据
    - Map用于按照key索引到双向链表节点
    - 查询
        - 直接访问哈希表
        - 如果存在，通过key，索引到节点，在双向链表中删除该节点
        - 通过新的value构造新节点，在双向链表的头部插入该节点
        - 通过前两步，表示该节点最近被使用过，放到最前边
        - 时间复杂度O(1)
    - 更新
        - 如果节点存在
            - 通过key，索引到节点，在双向链表中删除该节点
            - 通过新的value构造新节点，在双向链表的头部插入该节点
            - 通过前两步，最新的节点要放到前边
        - 如果节点不存在
            - 判断容量是否达到上限
            - 如果达到上限，先删除双向链表尾节点
            - 通过新的value构造新节点，在双向链表的头部插入该节点
        - 时间复杂度O(1)
    - 删除
        - 通过key索引到节点
        - 直接在双向链表中删除节点即可
        - 时间复杂度O(1)
    - 为什么使用双向链表
        - 涉及到更新/删除任意位置的节点
        - 如果使用单向链表，需要遍历，时间复杂度O(n)，使用双向链表，时间复杂度O(1)
        
## 心得总结
### 递归
1. 之前不是很理解递归，对递归一直很头疼，不知道如何下手写递归
2. 按照递归模板，可以写出基本结构，但需要判断好终止条件，并及时复原或清理过程数据
3. 通过学习课上老师对例题的讲解和线下实践，加深了对递归的理解
### 分治
1. 之前没有学习过，只是听说，通过课上学习，有了简单了解
2. 需要找同类的算法题，通过实践加深理解
