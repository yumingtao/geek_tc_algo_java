# Week-03总结
## 知识点总结
### 树
1. 满二叉树，满叶子节点
2. 完全二叉树，满二叉树右子树缺少部分叶子节点
3. java代码定义一棵树
```
public class TreeNode{
    public int vall
    public TreeNode left;
    public TreeNode right;
    
    public TreeNode(int val){
        this.val = val;
        this.left = null;
        this.right = null;
    }
}
```
4. 二叉树的遍历
    - 深度优先遍历
        - 前序遍历: 根左右
        - 中序遍历: 左根右
        - 后序遍历: 左右根
        - 以上遍历，其中的序，是指遍历根的顺序，根在前、中、后
        - 使用递归遍历树
    - 层次序，也叫广度优先遍历
        - 一层一层从左到右遍历
        - 使用队列遍历，利用队列的先进先出特性
5. 基环树
    - 一个树加一条边，形成一个环
### 图
1. 基本知识
    - 有点和边组成
    - 有向图，边有方向的图
    - 无向图，边没有方向，可以看成两条互为相反方向的边
2. 图和树、链表之间的关系
    - 链表是特殊话的树，一个节点有且仅有一个子节点
    - 树是特殊话的图
        - 基环树是N个点N条边的联通无向图
        - 树是N个点N-1条边的联通无向图
3. 图的三种存储方式
    - 邻接矩阵，空间复杂度O(n*n)
    - 出边数组，推荐使用，空间复杂度O(n+m)
    - 邻接表,空间复杂度O(n+m)，注意增加边时插入到链表的头部，防止添加到其它位置需要遍历链表
4. 图的遍历，遍历每个节点，每条边，时间复杂度O(n)
    - 图的遍历，需要标记节点是否被访问过
    - 深度优先遍历，
        - 一般用于
            - 无向图找环
            - 环分连通块
        - 使用递归遍历
        - 模版
        ```
            //1.先将节点标记已访问
            //2.添加处理逻辑
            //3.递归调用
        ```
    - 广度优先遍历，
        - 一般用于
            - 有向图找环
            - 拓扑排序
        - 使用队列，利用队列先进先出特性进行遍历
        - 模板
        ```
            //1.先将节点加入队列
            //2.再将节点标记为已访问
            while(队列不为空){
                //3.出队，添加处理逻辑
                //4.遍历当前节点的所有子节点，并依次加入队列
            } 
        ```
    - 注意深度优先遍历和广度优先遍历时，标记节点已访问过的顺序区别
### 状态和状态空间
1. 思考一个问题时，包含很多信息
    - 题面中涉及的所有数学信息
    - 人力计算关注的所有数据
    - 函数访问时涉及到的参数，局部变量，返回值
2. 什么是状态
    - 程序维护的所有动态数据构成的集合
    - 有些信息在我们处理和计算过程中只会参与计算，但是不会变化
    - 只关注动态变化的数据
3. 状态空间和图的关系
    - 什么是状态空间
        - 状态空间指所有可能状态构成的集合
    - 状态空间抽象为图
        - 把状态抽象为点
        - 一个状态到另一个状态，中间可以抽象出一条有向边
        - 整个状态空间就抽象成了一张图
        - 对一个问题的求解就抽象成了对这张图的遍历
4. 状态的简化
    - 在状态变化的过程中，有些信息是由其它数据来决定的，不影响状态的规模，只是一个附加信息
    - 把附加信息从状态中排除，就得到了最简状态
    - 问题的复杂度其实由最简状态决定
### 搜索
1. 什么是搜索
    - 采用直接遍历整个状态空间的方式求解问题的一类算法
    - 当一个问题不能通过多项式(NP)来解决时，通常采用搜索的方式来求解，比较暴力
    - 一般来说每个状态只遍历一次，当状态空间是图而不是树时，要盼重，如通过遍历图时，标记节点是否访问过
2. 按照遍历状态空间方式的不同，可以将搜索划分为
    - 深度优先搜索，DFS（depth first search）
    - 广度优先搜索，BFS（breadth first search）
3. DFS vs BFS
    - DFS
        - 更适合搜索树形状态空间
        - 递归本身就会产生树形结构
        - 可以用一个全局变量维护状态中复杂的信息
        - 不需要队列，节省空间
    - BFS
        - 适合求"最小代价"、"最小步数"的问题
        - 按层次一层一层搜索，当前层搜索完才会搜索下一层
        - 需要使用队列，任意时刻队列中至多只有两层的节点信息
    - 当需要判重时，两者差不多

## 算法思路总结
### 树的递归
1. 考虑当前层，以此归纳，如: 处理当前val + 处理（左子树）+ 处理（右子树）
2. 广度优先遍历，借助队列，主要思路：
```
while(队列不为空){
    //1. 出队，得到当前节点A
    //2. 入队A的left，right节点
}
```
3. 深度优先遍历，使用递归，注意递归终止的条件和还原现场
### 搜索题的解题思路和步骤
1. 通过模拟，提取信息
2. 定义状态，找出动态变化的信息，根据变化，勾勒出整个状态空间
3. 确定遍历采用DFS还是BFS
4. 参照DFS和BFS搜索的模板，定义搜索框架
    - 如果是DFS
        - 采用递归，状态做为参数逐层传递
        - 确定递归的边界，即终止条件
        - 注意还原现场，即一些状态数据的添加和删除成对出现
    - 如果是BFS
        - 使用队列，逐层遍历
    - 根据实际问题，考虑是否需要判重
5. 程序实现问题的解决思路

### 地图类问题的解题思路
1. 通常会用到DFS或BFS
2. 需要判断重复访问
3. 会使用方向数组
    - 方向数组定义模板
    ```
        //上北，下南，左西，右东
        //对应坐标轴的四个方向
        int dx = {-1, 0, 0, 1};
        int dy = {0, 1, -1, 0};
    ```
