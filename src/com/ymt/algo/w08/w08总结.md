# Week-08总结

## 知识点总结

### 图论算法
#### 图的基本概念
1. 图表示为一个点集和一个边集，Graph(V,E)
    - V:vertex
        - 入度：一个点相连的入边
        - 出度：一个点相连的出边
    - E:edge
        - 有向边
        - 无向边，可以理解成两个点之间有方向相反的两条边
        - 带权图：边带有权值（长度）
    
2. 图有三种方式存储
    - 邻接矩阵
    - 出边数组：常用
    - 邻接表
    
3. 图的遍历
    - 深度优先遍历：使用递归
    - 广度优先遍历：
      - 使用队列，利用队列先进先出特性 
      - 逐层遍历，同一时刻，队列里最多有两层的节点数据
    
#### 最短路径问题
##### 单源最短路径问题（SSSP: Single Source Shortest Path）
1. 问题描述
    - 有向图G=(V,E)，n个点，m条边
    - 节点以[1,n]之间的连续整数编号，1为起始点
    - (x,y,z): x->y的长度为z的有向边
      
2. 问题求解
    - 求长度为n的数组dist，dist[i]表示从起点1到节点i的最短路径长度

3. Bellman-Ford 算法
   - 基于动态规划和迭代算法
   - 扫描所有边(x,y,z)，若dist[y]>dist[x]+z,用dis[x]+z更新dist[y]
   - 重复上一步操作，知道没有更新操作发生
   - 如果问题有解，时间复杂度O(nm)，其中n是点的数量，m是边的数量
      - 问题有解：没有负环
      - 一条最短路径最多包含n-1条边，所以扫描所有边并奉新的过程最多执行n-1轮
      - 可以把每一轮看作DP的一个阶段，i轮至少已经求解出了包含边数不超过i的最短路径
   - 算法模板
   ```
      //1.初始化dist[n+1],注意点是从1到n，所以数组长度为n+1，一般初始值设置为(int)1e9, 起始点dist[k]=0;
      //2.for(int i = 1; i < n; i++){
            //用来判断是否还有更新
            boolean isUpdated;
            //循环所有的边(x,y,z)
            for(int j = 0; j < m; j++){
               if(dist[x] + z > dist[y]){
                  dist[y] = dist[x] + z;
                  //表示还有更新
                  isUpdated = true;
               }
            }
            
            //如果没有更新，跳出循环
            if(!isUpdated){
               break;
            }
        }
      //3.处理dist,找出最短路径
   ```
4. Dijkstra算法
   - 解法1：基于贪心算法，适用于边长都是非负数的图
      - 初始化distp[1]=0,其余节点dist值为正无穷大
      - 找出一个未被标记的，dist[x]最小的节点x，然后标记该节点
      - 扫描节点x的所有出边(x,y,z),若dist[y]>dist[x]+z,使用dist[x]+z更新dist[y]
      - 重复上边两个步骤，知道所有的节点都被标记
      - 贪心思路：当一个点最优的时候再去更新其它点
         - 前边都已经算过了，每次取所有剩下里最小的，局部最优，保证全局最优
         - 在非负权图上，全局最小的dist值不可能再被其它节点更新，因为已经被标记过（保证每个点只被取一次） 
         - 所以可以不断的取dist最小的点，更新其它点
      - 时间复杂度：使用二叉堆维护最小dist，可以做到O(mlogn),整体O(nmlogn)
   
   - 解法2：BFS + 优先队列
      - 如果边权都是1，可以使用BFS求最短路径 
      - 因为队列中点路径长度满足单调性和两段性，永远只有第k和k+1层，可以保证按层数搜索，每个点只访问一次
      - 如果边权是任意负数，可以使用优先队列+BFS，来保证从扩展路径最短的点
   
   - 总之：以上两种解法都是从当前最小的开始
   
5. Floyd算法 - 求每一对点之间的最短路径
   - 本质上是动态规划算法
   - 时间复杂度O(n^3)
   - 思路：
      - dp[k,i,j]表示经过编号不超过k的点为中继，从i到j的最短路径
      - 决策：是否使用k这个中继点dp[k,i,j] = min(dp[k-1,i,j], dp[k-1,i,k]+dp[k-1,k,j])
      - 去掉一维就变为d[i,j]=min(d[i,j], d[i,k]+d[k,j])
      - 初始态，d为图的邻接矩阵表示
   
6. 三种算法对比
   - Bellman-Ford算法：基于动态规划+迭代算法，求起始点i到图中每个节点的最短路径，时间复杂度O(nm)
   - Dijkstra算法：基于BFS+队列/优先队列，求起始点i到图中每个节点的最短路径，时间复杂度O(mlogn)
   - Floyd算法：基于动态规划，求每一对点之间的最短路径,时间复杂度O(n^3)
   
#### 最小生成树问题：MST - Minimum Spanning Tree
1. 描述
   - G(V,E)表示无向带权图，n表示点的数量，m表示边的数量
   - 由全部n个顶点和E中n-1条边构成的无向连通图被称为G的一个生成树
   - 边权之和最小的生成树，称为G的最小生成树
   
2. 特性
   - 任意一棵MST中，一定包含G中权值最小的边
   
3. 从描述+特性可以推论出，把任何一个生成森林扩展为生成树，一定使用了G中剩余边中权值最小的
   - 生成森林：指没有全部连通的图
   - 可以树上加一条边形成环+反证法来证明
      - 树上加一条边，形成环，就不是树了
      - 反证法：如果不是使用了途中剩余边权值最小的，和MST定义相悖
   
4. Kruskal算法 - 总是使用并查集维护无向图的MST，时间复杂度为O(mlogm)，算法思路
   - 建立并查集，每个点指向自己，各自构成一个集合（即并查集的定义）
   - 把所有的边按照权值从小到大排序，一次扫描每条边(x,y,z)
   - 若x，y属于同一个集合（连通），则忽略这条边，继续扫描下一条边
   - 若x，y不属于同一个集合（不连通），合并x,y（合并并查集），同时把z累加到答案中
   - 全部边都扫描完成后，就构成了一棵MST

### 字符串处理
#### Rabin-Karp算法 - 一种基于hash的高效搜索算法
1. 选用的hash函数
    - 把字符串看作一个b进制，计算它在十进制下对p取模的值
    - b的选择：一般会用经验值131，13331等形如'1(奇数个3)1'的形式
    - p的选择：选择较大的质数，如1e9+7
    - 注意：
        - 字符串Hash值相等，字符串并不绝对绝对相等，但相当大概率是相等的，这取决于hash函数的质量，由b和p决定。
        - 为了避免hash碰撞，可以再判等一下两个字符串

2. 快速计算字串的hash值
    - 先计算前缀字串的hash值，公式H[i]=Hash(s[0...i-1])=(H[i-1]*b+s[i-1]) mod p
        - 时间复杂度O(n)
    - 字串的hash值相当于b进制下，两个数做减法
        - Hash(s[l...r])=(H[r+1]-H[l]*b^(r-l+1)) mod p 
        - 求出字串的时间复杂度O(1)
    
3. Rabin-Karp算法的应用
    - 特性：
        - 预处理时间复杂度O(n)
        - 求出任意字串时间复杂度O(1)
    - 配合二分查找+二分答案，可以做为字符串匹配，回文等一些列问题的次优解，可能比最优解多一个log的时间复杂度